<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Kamera Ultra Smooth Zoom</title>
  <style>
    body {
      background-color: #121212;
      color: #ffffff;
      font-family: 'Segoe UI', sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      padding: 20px;
    }

    video {
      max-width: 100%;
      border-radius: 10px;
      background-color: #000;
      transform-origin: center;
      transition: transform 0.3s ease;
    }

    input[type="range"] {
      width: 300px;
    }

    button {
      padding: 10px 15px;
      margin: 5px;
      border: none;
      background-color: #1f1f1f;
      color: white;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }

    button:hover {
      background-color: #333;
    }

    a {
      margin-top: 10px;
      color: #4caf50;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <h2>Kamera HD + Ultra Smooth Zoom + Flash</h2>
  <video id="preview" autoplay muted playsinline></video>

  <div>
    <label>Zoom:</label>
    <input type="range" id="zoomControl" min="1" max="3" step="0.01" value="1">
  </div>

  <div>
    <button id="flipCamBtn">Ganti Kamera</button>
    <button id="mirrorBtn">Flip Horizontal</button>
    <button id="flashBtn">Toggle Flash</button>
  </div>

  <div>
    <button id="startBtn">Mulai Rekam</button>
    <button id="stopBtn">Stop</button>
  </div>

  <a id="downloadLink" style="display:none;" download="rekaman_hd.webm">Download Rekaman</a>
  <video id="recordedVideo" controls style="display:none;"></video>

  <script>
    let mediaRecorder;
    let recordedBlobs = [];
    let videoTrack;
    let stream;
    let usingFrontCamera = true;
    let isMirrored = false;
    let isTorchOn = false;

    const preview = document.getElementById('preview');
    const recordedVideo = document.getElementById('recordedVideo');
    const zoomControl = document.getElementById('zoomControl');
    const downloadLink = document.getElementById('downloadLink');
    const flashBtn = document.getElementById('flashBtn');

    let currentZoom = 1;
    let targetZoom = 1;

    function lerp(a, b, t) {
      return a + (b - a) * t;
    }

    function animateZoom() {
      if (!videoTrack) return;
      const diff = Math.abs(currentZoom - targetZoom);
      if (diff < 0.001) {
        currentZoom = targetZoom;
      } else {
        currentZoom = lerp(currentZoom, targetZoom, 0.05); // Lebih halus
      }

      videoTrack.applyConstraints({ advanced: [{ zoom: currentZoom }] }).catch(() => {});
      requestAnimationFrame(animateZoom);
    }

    async function startCamera() {
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
      }

      const constraints = {
        audio: true,
        video: {
          facingMode: usingFrontCamera ? 'user' : 'environment',
          width: { ideal: 1920 },
          height: { ideal: 1080 },
          zoom: true,
          torch: true
        }
      };

      try {
        stream = await navigator.mediaDevices.getUserMedia(constraints);
        preview.srcObject = stream;

        videoTrack = stream.getVideoTracks()[0];
        const capabilities = videoTrack.getCapabilities();

        // Setup Zoom
        if (capabilities.zoom) {
          zoomControl.min = capabilities.zoom.min;
          zoomControl.max = capabilities.zoom.max;
          zoomControl.step = capabilities.zoom.step || 0.01;
          currentZoom = targetZoom = videoTrack.getSettings().zoom || 1;
          zoomControl.value = currentZoom;
          zoomControl.disabled = false;

          zoomControl.oninput = () => {
            targetZoom = parseFloat(zoomControl.value);
          };

          animateZoom(); // Start zoom animation
        } else {
          zoomControl.disabled = true;
        }

        // Setup Flash
        if (capabilities.torch !== undefined) {
          flashBtn.style.display = 'inline';
        } else {
          flashBtn.style.display = 'none';
        }

        // Setup Recorder
        mediaRecorder = new MediaRecorder(stream);
        mediaRecorder.ondataavailable = (e) => {
          if (e.data.size > 0) recordedBlobs.push(e.data);
        };

        mediaRecorder.onstop = () => {
          const blob = new Blob(recordedBlobs, { type: 'video/webm' });
          const url = URL.createObjectURL(blob);
          recordedVideo.src = url;
          recordedVideo.style.display = 'block';
          downloadLink.href = url;
          downloadLink.style.display = 'inline';
        };

        preview.style.transform = isMirrored ? 'scaleX(-1)' : 'scaleX(1)';
      } catch (err) {
        alert('Gagal mengakses kamera: ' + err.message);
        console.error(err);
      }
    }

    document.getElementById('startBtn').onclick = () => {
      recordedBlobs = [];
      mediaRecorder.start();
    };

    document.getElementById('stopBtn').onclick = () => {
      mediaRecorder.stop();
    };

    document.getElementById('flipCamBtn').onclick = () => {
      usingFrontCamera = !usingFrontCamera;
      startCamera();
    };

    document.getElementById('mirrorBtn').onclick = () => {
      isMirrored = !isMirrored;
      preview.style.transform = isMirrored ? 'scaleX(-1)' : 'scaleX(1)';
    };

    flashBtn.onclick = () => {
      if (!videoTrack) return;
      isTorchOn = !isTorchOn;
      videoTrack.applyConstraints({ advanced: [{ torch: isTorchOn }] }).catch(err => {
        alert('Flash tidak tersedia di perangkat ini.');
        console.error(err);
      });
    };

    startCamera();
  </script>
</body>
</html>